{{#template name="tutorials.socially.angular1.step_08.md"}}
{{> downloadPreviousStep stepName="step_07"}}

Один из наиболее мощных Meteor пакетов - это система аккаунтов Meteor.

Прямо сейчас наше приложение публикует все вечеринки, всех клиентов и клиенты могут менять эти вечеринки. Изменения отображаются у всех клиентов автоматически. 

Это супермощно и легко, но что по поводу безопастности? Мы не хотим, чтобы любой пользователь менял вечеринку...

Сперва нам унжно убрать небезопасный пакет, который автоматически добавляется к любому приложению Meteor.

'Небезопасный' пакет по-умолчанию предоставляет полный доступ всем к коллекциям Meteor.

Удалив этот пакет по-умолчанию мы запретим всем доступ.

Сделайте это выполнив команду:

    $ meteor remove insecure

Теперь попробуем сменить массив вечеринок или отдельную вечеринку. Мы получим:

    remove failed: Access denied
    
В консоли, так как у нас нет разрешение сделать это.

Теперь, нам нужно написать дополнительное правило безопастности для каждой операции с Mongo коллекцией, которую мы хотим разрешить клиенту выполнять.

Во-первых, добавим пакет `accounts-password`.
Это очень мощный пакет для всех операций пользователя, о которых вы хотите подумать: вход, подписка, смена пароля, восстановление пароля, подтверждение email и остальное.

    $ meteor add accounts-password

Также мы добавим пакет `dotansimha:accounts-ui-angular`. Этот пакет содержит все HTML и CSS, которые нам нужны для операций пользователя с формами.

Позже в этом уроке мы заменим формы по-умолчанию в account-ui формами Angular 1.

    $ meteor add dotansimha:accounts-ui-angular

Давайте добавим зависимость модуля `accounts.ui` к нашему определению модуля.

{{> DiffBox tutorialName="meteor-angular1-socially" step="8.4"}}

Добавим директиву `login-buttons` (часть модуля `accounts.ui` module) в наше приложение в файл index.html.

Теперь наш `index.html` примет вид:

{{> DiffBox tutorialName="meteor-angular1-socially" step="8.5"}}

Запустите код, создайте аккаунт, вход, выход...

Теперь у нас есть аккаунт система, мы можем начать определять наши правила безопастности для вечеринок.

Перейдём к папке моделей и сменим её вид на такой:

{{> DiffBox tutorialName="meteor-angular1-socially" step="8.6"}}

[Функция Meteor collection.allow](http://docs.meteor.com/#/full/allow) определяет разрешения необходимые клиенту для записи напрямую в коллекцию (что мы и делали до сих пор).

В каждом колбеке типов действий (insert, update, remove) функции должны возвращать true, если они думают, что операции должны быть разрешены.
Иначе они должны возвращать false или совсем ничего (undefined).

Доступные колбеки:

* `insert(userId, doc)`

  Пользователь userId хочет вставить документ doc в коллекцию. Возвращает true если это позволено.

  doc будет содержать _id поле, если оно избыточно было установлено клиентом или есть активная трансформация. Вы можете использовать это для защиты пользователей от определения _id полей.

* `update(userId, doc, fieldNames, modifier)`

  Пользователь userId хочет обновить документ doc. (doc - это текущая версия документа из базы данных, без предложенного обновления). Возвращает true при разрешении изменений.

  fieldNames - это массив (top-level) полей в doc, которые хочет поменять пользователь например ['name', 'score'].

  modifier это также чистый Mongo подификатор, который хочет выполнить клиент, например {$set: {'name.first': "Alice"}, $inc: {score: 1}}.

  Поддерживаются только Mongo модификаторы (операции типа $set и $push). Если пользователь пытается заменить весь документ вместо использования $-modifiers, запрос будет запрещён без проверки фукнций разрешения.

* `remove(userId, doc)`

  Пользователь userId хочет удалить doc из базы данных. Возвращает true для разрешения.


В нашем примере:

* insert - только если пользователь, который вставляет вечеринку, владелец вечеринки.
* update - только если пользователь, который обновляет вечеринку, владелец вечеринки.
* remove - только если пользователь, который удаляет вечеринку, владелец вечеринки.


Отлично, сейчас у наших вечеринок есть владелец, поэтому мы не можем их менять. 

Давайте добавим следующий простой код для определения владельца каждой создаваемой вечеринки.

Мы можем использовать метод `Meteor.userId()`, который возвращает текущий пользовательский id. 

Мы будем использовать этот id, который добавляет его к нашей новой вечеринке:

{{> DiffBox tutorialName="meteor-angular1-socially" step="8.7"}}

Во-первых назначим нового владельца вечеринки к нашему id и далее вставим коллекцию вечеринок как ранее.

Теперь запустим приложение в двух разных браузерах и войдём двумя разными пользователями.

Протестируем редактирование и удаление наших вечеринок и попробуем сделать то же для вечеринок другим пользователем.

# Вход через социальные службы

Также мы ходим, чтобы пользователи логинились через свои Facebook и Twitter аккаунты.

Для этого нужно просто добавить нужные пакеты из консоли:

    meteor add accounts-facebook accounts-twitter

Теперь запустите приложение, как только вы нажмёте login кнопки соцвхода, meteor покажет вам мастера, который поможет определить ваше приложение.

Можете также пропустить мастера и сконфигурировать это вручную, как описано здесь: [http://docs.meteor.com/#meteor_loginwithexternalservice](http://docs.meteor.com/#meteor_loginwithexternalservice)

Существует множество соцсервисов, которые можете использовать:

* Facebook
* Github
* Google
* Meetup
* Twitter
* Weibo
* Meteor developer account


# Авторизация с помощью маршрутов

Теперь у нас авторизованые пользователи не могут менять вечеринки, которыми они не владеют, и нет для них необходимости переходить на страницу деталей вечеринки.

Мы можем легко запретить им это делать через использование маршрутов.

Будем использовать API Метеора снова, а также AngularJS `$q` для легкого создания промисов.

Наш промис будет решать залогинен ли пользователь и если нет, то отказывать ему в доступе.

Мы собираемся использовать объект [resolve](https://github.com/angular-ui/ui-router/wiki#resolve) наших ui-router и ngRoute:

{{> DiffBox tutorialName="meteor-angular1-socially" step="8.9"}}

Теперь, если пользователь не залогинен в систему, у него не будет доступа к этому маршруту.

Также нам нужно обработать этот сценарий и перенаправить пользователя на главную страницу.

Наверху файла маршрутов, давайте добавим эти строчки (блок `run`) и мы также добавим "причину" для вызова `reject()` для определения или это наш reject вызвал ошибку маршрута.

{{> DiffBox tutorialName="meteor-angular1-socially" step="8.10"}}

# Итоги

Удивительно, только пара строчек кода и у нас уже безопастное приложение!

Обратите внимание, что кто-то с вредными намерениями может перезаписать ваш маршрут в клиенте (в файле client/routes.js). 
Так как там мы проверяем авторизацию пользователя, то они могут убрать проверку и получить доступ.
Вы никогда не должны ограничивать доступ к важным данным или областям, используя клиентский маршрутизатор.
По этому причине мы также ввели ограничения на сервере, используя allow/deny функциональность, поэтому, если кто-то получит их, то не сможет делать обновления.
Несмотря на то, что это предотвращает запись в незапланированные источники, чтение из них по-прежнему возможно.
В следующем шаге мы позаботимся о безопастности, убрав из показа вечеринки для пользователей, которые не должны их видеть.

{{/template}}