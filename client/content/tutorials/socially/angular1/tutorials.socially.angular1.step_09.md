{{#template name="tutorials.socially.angular1.step_09.md"}}
{{> downloadPreviousStep stepName="step_08"}}


Публикация и подписка на данные очень отличается от других методов, как например от REST API. Поэтому не пропустите ниженаписанное для более глубокого понимания их работы.


Сейчас в приложении не настроены частные разделы, поэтому пользователь может видеть все вечеринки.

Добавим флаг `public` для вечеринок - если какая-то вечеринка публичная, то каждый сможет её увидеть, если частная - только владелец.

Сперва нужно удалить пакет `autopublish`.

`autopublish` добавляется автоматически к каждому проекту Метеор. Он отдаёт полную копию базы данных к каждому клиенту.
Он помогал нам прежде, но он не настолько хорош для частных разделов...

Напишите эту команду в консоли:

    meteor remove autopublish


Теперь запустите приложение. Вы не увидите вечеринок.

Теперь нужно сообщить Meteor, что вечеринки должны быть опубликованы для клиентов.

Сделаем это с помощью [publish функций Meteor](http://docs.meteor.com/#/full/meteor_publish).

Функции публикации должны выполняться только на сервере, поэтому клиент не будет иметь к ним доступа.

Создадим новый файл, с имененм `parties.js` всередине папки server.

Вставим в него этот код:

{{> DiffBox tutorialName="meteor-angular1-socially" step="9.2"}}

Давайте посмотрим, что произошло:

* У нас есть `Meteor.publish` - функция для определения что публиковать от сервера клиенту
* Первый параметр - это название подписки. Клиент будет подписан на это имя
* Второй параметр - это функция, которая определяет, что возвратится в подписке

Вы можете познакомиться подробнее с MongoDB методом `find()` [здесь](http://docs.mongodb.org/manual/reference/method/db.collection.find/)

Эта функция определит какие данные будут возвращены и какие нужны разрешения.

В нашем случае первый параметр - это **"parties"**. Поэтому нам нужно подписаться на коллекцию **"parties"** в клиенте, давайте сделаем это используя метод `this.subscribe`:

{{> DiffBox tutorialName="meteor-angular1-socially" step="9.3"}}

> Наша функция публикации также берёт параметры. В этом случае нам также нужно передавать параметры из клиента.

> Для подробной информацией по сервису `subscribe` [перейдите сюда](/api/reactive-context)

Во втором параметры функции публикации, мы определяем функцию использующую Mongo API для возврата необходимых документов (документы в базе данных Mongo храняться в JSON-формате).

Создадим запрос коллекции Parties.

Всередине метода find мы будем использовать [$or](http://docs.mongodb.org/manual/reference/operator/query/or/), [$and](http://docs.mongodb.org/manual/reference/operator/query/and/) и [$exists](http://docs.mongodb.org/manual/reference/operator/query/exists/) Mongo операторы для получения необходимых вечеринок:

Если наш параметр пользователя существует и это текущий залогиненный пользователь (к которому у нас есть доступ через команду `this.userId`) или флаг вечеринки public существует и установлен в true.

Давайте добавим флаг public к вечеринкам и увидим как он влияет на вывод вечеринок к клиенту.

Добавим чекбокс к новой форме вечеринки в `parties-list.html`:

{{> DiffBox tutorialName="meteor-angular1-socially" step="9.4"}}

Обратите внимание на лёгкость связывания чекбокса и модели с помощью Angular 1!

Проделаем то же самое со страницей `party-details.html`:

{{> DiffBox tutorialName="meteor-angular1-socially" step="9.5"}}

Мы добавим возможность устанавливать этот флаг при обновлении деталей вечеринки:

{{> DiffBox tutorialName="meteor-angular1-socially" step="9.6"}}

Запустим теперь приложение:

Войдите 2 разными пользователями через 2 браузера (вы можете использовать 2 разных браузера, например, Chrome и Firefox или использовать анонимный режим в том же браузере, например, инкогнито в Chrome, private browsing в Firefox или inPrivate режим в Edge).

В каждом пользователе создайте несколько публичных и несколько частных вечеринок.

Теперь разлогинтесь и посмотрите какой пользователь видит какие вечеринки.


На следующем шаге, мы пригласим пользователей к частным вечеринкам. Для этого нам нужно добавить всех пользователей. Но только их emails без других данных, которые могут затронуть их приватность.

Давайте создадим ещё один метод публикации для получения только необходимых данных пользователя.

Обратите внимание, что нам  не нужно создавать новую коллекцию Метеор как мы делали для вечеринок. **Meteor.users** - это предопределённая коллекция, которая определена пакетом [meteor-accounts](http://docs.meteor.com/#accounts_api).

Давайте начнём с определения наших функций публикации.

Создайте новый файл в папке `server` с именем `users.js` и поместите туда код:

{{> DiffBox tutorialName="meteor-angular1-socially" step="9.7"}}

Снова мы использовали Mongo API для выдачи всех пользователей (find с пустым объектом) но мы выбрали к выдаче только email и поля профиля.

* Обратите внимание, что каждый объект (польователь, например) будет содержать поля `_id`.

Поля email содержат все адреса email пользователей и профиль может содержать больше информации, например, имя пользователя (в нашем случае
если пользователь залогинен с помощью Facebook аккаунта, то пакет accounts-facebook возьмёт из Facebook имя автоматически в это поле).

Давайте подпишемся на этот метод публикации. В файле компонента `partyDetails` добавьте следующую строку всередине контроллера:

{{> DiffBox tutorialName="meteor-angular1-socially" step="9.8"}}

* Мы подписались к публикации `users`
* Мы добавили функцию-хелпер к коллекции `users`

Давайте добавим список пользователей к отображению, чтобы убедится, что оно работает.

Добавим этот ng-repeat список в конец `party-details.html`:

{{> DiffBox tutorialName="meteor-angular1-socially" step="9.10"}}

Также давайте добавим подписку к `parties` в этом компоненте, в том случае, если мы будем загружать приложение прямо в этом компоненте пред загрузкаой компонента parties-list:

{{> DiffBox tutorialName="meteor-angular1-socially" step="9.9"}}

Запустите приложение и вы увидите список email клиентов, которые создали логин и пароль, но не использовали сервис для входа.

# Работа с коллекциями пользователей Users на клиенской стороне

Обратите внимание, что структура коллекции Users отличается от обычной email-password, Facebook, Google и т.д.

Структура документа выглядит так (обратите внимание, где находятся email каждого ряда):

__`Email-Password`:__

    {
      "_id" : "8qJt6dRSNDHBuqpXu",
      "createdAt" : ISODate("2015-05-26T00:29:05.109-07:00"),
      "services" : {
        "password" : {
          "bcrypt" : "$2a$10$oSykELjSzcoFWXZTwI5.lOl4BsB1EfcR8RbEm/KsS3zA4x5vlwne6"
        },
        "resume" : {
          "loginTokens" : [
            {
              "when" : ISODate("2015-05-26T00:29:05.112-07:00"),
              "hashedToken" : "6edmW0Wby2xheFxyiUOqDYYFZmOtYHg7VmtXUxEceHg="
            }
          ]
        }
      },
      "emails" : [
        {
          "address" : "email@email.com",
          "verified" : false
        }
      ]
    }

__`Facebook`:__

    {
      "_id" : "etKoiD8MxkQTjTQRY",
      "createdAt" : ISODate("2015-05-25T17:42:16.850-07:00"),
      "services" : {
        "facebook" : {
          "accessToken" : "CAAM10fSvI...",
          "expiresAt" : 1437770457288.0000000000000000,
          "id" : "10153317814289291",
          "email" : "email@email.com",
          "name" : "FirstName LastName",
          "first_name" : "FirstName",
          "last_name" : "LastName",
          "link" : "https://www.facebook.com/app_scoped_user_id/foo"
          "gender" : "male",
          "locale" : "en_US"
        },
        "resume" : {
          "loginTokens" : []
        }
      },
      "profile" : {
        "name" : "First Name LastName"
      }
    }

__`Google`:__

    {
      "_id" : "337r4wwSRWe5B6CCw",
      "createdAt" : ISODate("2015-05-25T22:53:32.172-07:00"),
      "services" : {
        "google" : {
          "accessToken" : "ya29.fwHSzHvC...",
          "idToken" : "eyJhbGciOiJSUzI1NiIs...",
          "expiresAt" : 1432624691685.0000000000000000,
          "id" : "107497376789285885122",
          "email" : "email@email.com",
          "verified_email" : true,
          "name" : "FirstName LastName",
          "given_name" : "FirstName",
          "family_name" : "LastName",
          "picture" : "https://lh5.googleusercontent.com/-foo.jpeg"
          "locale" : "en",
          "gender" : "male"
        },
        "resume" : {
          "loginTokens" : [
            {
              "when" : ISODate("2015-05-25T23:18:11.788-07:00"),
              "hashedToken" : "NaKS2Zeermw+bPlMLhaihsNu6jPaW5+ucFDF2BXT4WQ="
            }
          ]
        }
      },
      "profile" : {
        "name" : "First Name LastName"
      }
    }


Прямо сейчас это значит, что email залогиненных пользователей с помощью email-пароля будут отображены.

В главе "Angular 1 фильтры" мы поменяем код вывода для показа всех email.


# Понимание публикация-подписка

Важно понять механизм Метеора публикация-подписка, чтобы вы не путались и использовали его в фильтрах отображения!

Meteor включает все данные из различных подписок коллекций в клиенте, поэтому добавление другой подписки в другом отображении не удалит данные, которые уже находятся в клиенте.

Подробная информации о публикациях и подписках находится [в этой статье](https://medium.com/angular-meteor/coll-pub-sub-with-angular-meteor-cb13fe48f570) и в этой [meteorpedia статье](http://www.meteorpedia.com/read/Understanding_Meteor_Publish_and_Subscribe).

# Итоги

Мы добавили поддержку частных разделов в нашем приложении.

Также мы научились, как использовать команду `Meteor.publish` для управления разрешениями и данными, отправляемыми клиенту и как подписываться к ним с помощью функции $meteor.collection.

На следующем шаге мы научимся разворачивать приложение. Вы увидите как легко развернуть онлайн приложение Meteor.

{{/template}}
