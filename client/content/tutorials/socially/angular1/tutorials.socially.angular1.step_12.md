{{#template name="tutorials.socially.angular1.step_12.md"}}
{{> downloadPreviousStep stepName="step_11"}}

Сейчас мы работаем только с несколькими вечеринками, но что нужно сделать для поддержки их большего количества.

То есть нам нужна поддержка `пагинации`.

С пагинацией мы можем разбить массив вечеринок на страницы, таким образом пользователю не нужно будет прокручивать вниз для поиска вечеринки.
И также, что более важно, мы можем получить только несколько вечеринок за раз, вместо всей коллекции вечеринок для большей производительности.

Интересно что пагинация зависит от фильтров, которые мы хотим  положить на верх коллекций.
Например, если мы на странице 3, но хотим поменять направление сортировки коллекций, мы должны получить другие результаты.
То же самое с поиском: если мы начинаем поиск, то может быть не достаточно результатов на 3х страницах.

Для Angular 1 разработчиков эта глава покажет насколько мощным является Meteor.
В официальном уроке Angular 1 мы добавили сортировку и поиск, который работает только на клиенте, что в реальном примере не очень поможет.
Теперь в этой главе нам нужно осуществлять поиск в реальном времени, сортировку и пагинацию, которая будет работать и на сервере.

# angular-meteor поддержка пагинации

Что нам нужно сделать, так это angular-meteor *серверную реактивную пагинацию*.
Это не простая задача, но использование angular-meteor может намного упростить жизнь.

Чтобы реализовать серверную реактивную пагинцию нам нужно иметь поддержку на сервере, а также на клиенте.
Это значит, что наши функции публикации для коллекций вечеринок будут меняться и таким образом, что мы подпишимся на эту публикацию.
Давайте пока разберёмся с серверной стороной:

В нашем файле `parties.js` в папке server мы собираемся добавить переменную `options` для метода публикации, например так:

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.1"}}

Теперь наш метод публикации получает аргумент опций, который мы затем передаём в вызов функции `Parties.find()`.
Это позволит нам отсылать параметры в модификатор функции find прямо перед вызовом подписки. Объект с параметрами может содержать такие свойства как `skip`, `sort` и `limit`, которые мы скоро будем использовать - [подробнее о Collection Find](http://docs.meteor.com/#/full/find).

Вернёмся к нашему клиентскому коду. Нам нужно добавить в наш вызов о подписке опции, которые мы хотим установить для пагинации.
Что же это будут за опции? Для пагинации нам нужно в нашем списке вечеринок сохранить текущую страницу, количество вечеринок на странице и порядок сортировки. Давайте добавим эти параметры к нашему компоненту в файле `parties-list.component.js`.

Мы добавим переменные `perPage`, `page` и `sort`, которые потом повлияют на нашу подписку и мы хотим, чтобы подписка перезапускалась каждый раз как одна из них меняется.

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.2"}}

Прямо сейчас мы просто будем использовать `subscribe` без каких-либо параметров, но нам нужно задать некоторые аргументы для подписок.

С этой целью мы добавим второй параметр к методу `subscribe` и мы обеспечим функцию, которая возвратит массив аргументов для подписки.

Мы будем использовать `getReactively` с целью получения текущего значения и это сделает их также реактивными переменными и каждое их изменнение будет влиять на параметры подписки.

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.3"}}

Это значит, что `this.page` и `this.sort` теперь являются реактивными и Meteor будет перезапускать подписку каждый раз, когда одна из них изменится.

Теперь мы создадим объект, который содержит 3 свойства:

* **limit** - сколко вечеринок отправлять за страницу
* **skip**  - количество вечеринок для начала, это текущая страница минус один, количество вечеринок на странице
* **sort**  - сортировка коллекции в [MongoDB синтаксисе](http://docs.mongodb.org/manual/reference/method/cursor.sort/)

Также нам необходимо добавить модификатор сортировки, чтобы получить данные коллекции из Minimongo.
Это нужно сделать, так как сортировка не сохраняется, когда данные отправляются из сервера к клиенту.
Чтобы убедиться, что данные также отсортированы в клиенте, нам нужно это определить в коллекции вечеринок.

Чтобы сделать это мы добавим переменную `sort` и будем использовать её снова с `getReactively` с целью запуска хелпера каждый раз когда параметр `sort` меняется:

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.4"}}

# Директива пагинации

Теперь нам нужно, чтобы UI менял страницы и двигался между них.

В Angular 1 эко системе есть множество директив для управления пагинацией.

Наша любимая - это [angular-utils-pagination](https://github.com/michaelbromley/angularUtils/tree/master/src/directives/pagination).

Для добавления директивы добавьте этот Meteor пакет к проекту:

    meteor add angularutils:pagination

Для добавления её как зависимости к нашему Angular приложению в `app.js`:

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.6"}}

Теперь добавим директиву в `parties-list.html`, поменяем `ng-repeat` вечеринок для этого:

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.7"}}

и после закрытия UL добавьте эту директиву:

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.8"}}

Как видите, `dir-paginate` список берёт количество объектов на странице (которое мы ранее определили), но также берёт общее количество элементов (мы доберёмся до этого скоро).
С этим связыванием оно считает какие кнопки страницы оно должно выдавать всередине директивы `dir-pagination-controls`.

В директиве `dir-pagination-controls` существует метод `on-page-change` и там мы можем вызывать нашу собственную функцию.

Поэтому мы вызываем функцию `pageChanged` с новой выборкой как с параметром.

Создадим функцию `pageChanged` всередине компонента `partiesList`:

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.9"}}

Теперь каждый раз при смене страницы, переменная области видимости сменится соответственно и обновит метод связывания, который за ней наблюдает.

* Внимание! В этом моменте, пагинация *не будет работать* пока мы не добавим недостающую переменную `partiesCount` на следующем шаге этого урока.

# Получение общего количества коллекции

Получение общего количества коллекции может показаться простой задачей, но есть одна проблема:
Клиент только содержит количество объектов, на которые он подписан. Это ведёт к тому, что если клиент не подписан на весь массив, вызывая find().count на коллекции приведёт к частичному подсчёту.

Поэтому нам нужен доступ клиента к общему количеству, даже если мы не подписаны ко всей коллекции.

С этой целью мы можем использовать пакет [tmeasday:publish-counts](https://github.com/percolatestudio/publish-counts). 
В командной строке:

    meteor add tmeasday:publish-counts

Этот пакет поможет опубликовать количество курсора в реальном времени без какой-то зависимости от метода подписки.

Всередине файла `server/parties.js` добавьте код, который обрабатывает количество всередине функции `Meteor.publish("parties")` в начале функции перед существующем оператором return.
Теперь файл должен выглядеть так:

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.11"}}

Как видите мы запросили только вечеринки, которые должны быть доступны к этому соответствющему клиенту, но без переменной параметров, чтобы мы получили всё количество вечеринок.

* Мы передаём  `{ noReady: true }` последним аргементом, поэтому публикации будут готовы только после готовности главного курсора - [см. readiness](https://github.com/percolatestudio/publish-counts#readiness).

С этим у нас будет полный доступ к коллекции Counts из нашего клиента.

Создадим другой хелпер, который будет использовать `Counts`:

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.12"}}

Теперь `partiesCount` будет содержать количество вечеринок и будет посылать их директиве в `parties-list.html` (который мы уже ранее определили).

# Реактивные переменные

Meteor глубоко опирается на концепцию [реактивности](http://docs.meteor.com/#/full/reactivity).

Это значит, что когда [реактивная переменная](http://docs.meteor.com/#/full/reactivevar) меняется, то Meteor оповещается об этом через его [отслеживатель объектов](http://docs.meteor.com/#/full/tracker_autorun).

Но переменные области видимости Angular только наблюдаются Angular и не являются реактивными для Метеора...

Для этого angular-meteor содержит `хелперы`, и каждый раз при определении переменной, новый `ReactiveVar` будет создан и будет заставлять Трекер обновлять все подписки!


# Смена порядка сортировки реактивно

Мы не разместили способ смены сортировки где-либо в UI поэтому давайте сделаем это сейчас:

В нашем HTML шаблоне давайте добавим выпадающий список всередине UL:

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.13"}}

В компоненте развернём метод `updateSort`:

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.14"}}

> Обратите внимание, что мы также создали `orderProperty` с целью обеспечения доступности этого параметра с самого начала.

Нам не нужно делать что-либо ещё, так как мы определили сортировочную переменную `sort` как хелпер и когда мы поменяем её, Angular-Meteor позаботится об обновлении подписки для нас. 

Нам осталось только лишь сесть поудобнее и насладится тем как пагинация заработает по-щучьему велению.

Мы сделали много изменений поэтому, пожалуйста, проверьте код [здесь](https://github.com/Urigo/meteor-angular-socially/compare/step_14...step_15)
чтобы убедиться, что вы сделали всё возможное и можете запустить приложение.

# Реактивный поиск

Теперь, когда у нас есть база для пагинации, всё что осталось - это добавить полнореативный поиск вечеринок. Это значит, что мы сможем ввести строку поиска и приложение будет искать вечеринку соответствующую этому имени на сервере и возвратит только релевантные результаты! Это просто отлично и мы сделаем это всё всего лишь несколькими строчками кода. Давайте начнём!

Как и ранее добавим поддержку сервера. Нам нужно добавить новый аргумент к нашему методу публикации, который задержит запрошенную строку. Мы назовём её... `searchString`! Вот она:

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.15"}}

Теперь мы отфильтруем правильные результаты используя mongo regex возможности. Мы сделаем это добавив строку в эти два места, где мы используем `find`: в публикации Подсчёта количеств и в возврате курсора вечеринок:

    'name' : { '$regex' : '.*' + searchString || '' + '.*', '$options' : 'i' },

Теперь `server/parties.js` должен выглядеть так:

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.16"}}

Как видите, мы отфильтруем все вечеринки, чьи имена содержат searchString.

> Мы добавили также `if (searchString == null) searchString = '';`  для того, что когда мы не получаем этот параметр, мы возвращаем всю коллекцию. 

Перейдём к клиенту.
Во-первых давайте разместим серверный инпут в наш шаблон и привяжем его к переменной компонента 'searchText':

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.17"}}

Всё, что осталось сделать это вызывать метод подписки с нашими реактивными переменными и добавить `searchText` как реактивный помощник:

{{> DiffBox tutorialName="meteor-angular1-socially" step="12.18"}}

Ух ты! Всё что и нужно было для полного реактивного поиска с пагинацией! Отлично, не так ли?

# Итоги

Теперь у нас есть полноценная пагинация с поиском и сортировкой для клиента и сервера с помощью Meteor опций и директив Angular 1.

{{/template}}